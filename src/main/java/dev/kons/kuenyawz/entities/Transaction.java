package dev.kons.kuenyawz.entities;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonValue;
import dev.kons.kuenyawz.constants.PaymentType;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Special case, where transaction id (this entity id) should be defined first logically
 * before being saved to the database.
 */
@Entity
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@SuperBuilder
@Table(indexes = {
    @Index(name = "idx_transaction_status", columnList = "status")
})
public class Transaction extends Auditables {
	@Id
//	@SnowFlakeIdValue(name = "transaction_id")
	@Column(name = "transaction_id", columnDefinition = "BIGINT", updatable = false, nullable = false)
	private Long transactionId;

	/**
	 * This is generated by Midtrans, it is their internal transaction id for the current transaction.
	 */
	@Column(unique = true)
	private String referenceId;

	@Column
	private BigDecimal amount;

	@Column
	private String paymentUrl;

	@Column(nullable = false)
	@Enumerated(EnumType.STRING)
	private TransactionStatus status;

	@Column(nullable = false)
	@Enumerated(EnumType.STRING)
	private PaymentType paymentType;

	@Column
	private LocalDateTime expiresAt;

	@Column
	private LocalDateTime finalizedAt;

	@Version
	private Long version;

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "account_id", nullable = false)
	private Account account;

	@ManyToOne(fetch = FetchType.EAGER)
	@JoinColumn(name = "purchase_id", nullable = false)
	private Purchase purchase;

	/// Refer to [Midtrans Transaction Status](https://docs.midtrans.com/reference/transaction-status)
    @JsonFormat(shape = JsonFormat.Shape.STRING)
    @Getter
    public enum TransactionStatus {
		// Base status (custom)
		/**
		 * Transaction may have been created, but not yet authorized. This state indicates that
		 * the customer has not yet chosen a payment method or has not yet paid.
		 */
		@JsonProperty("created")
		CREATED("Transaction has been created"),

		/// Sub transaction status ~ flow

		@JsonProperty("authorize")
		AUTHORIZE("Transaction has been authorized"),

		@JsonProperty("capture")
		CAPTURE("Transaction has been captured, may move to settlement"),

		@JsonProperty("refund")
		REFUND("Transaction has been refunded"),

		@JsonProperty("partial_refund")
		PARTIAL_REFUND("Transaction has been partially refunded"),

		@JsonProperty("chargeback")
		CHARGEBACK("Transaction has been charged back"),

		@JsonProperty("partiial_chargeback")
		PARTIAL_CHARGEBACK("Transaction has been partially charged back"),

		@JsonProperty("failure")
		FAILURE("Transaction has failed due to unexpected errors"),

		/// Main transaction status ~ flow

		@JsonProperty("pending")
        PENDING("Payment yet to be paid"),

		@JsonProperty("SUCCESS")
		SUCCESS("Transaction has been successful"),

		@JsonProperty("settlement")
        SETTLEMENT("Transaction has been completed"),

		@JsonProperty("deny")
		DENY("Transaction has been denied"),

		@JsonProperty("cancel")
		CANCEL("Transaction has been canceled"),

		@JsonProperty("expire")
        EXPIRE("Transaction has expired");

        private final String description;

        TransactionStatus(String description) {
            this.description = description;
        }

        @JsonValue
        public String getValue() {
            return name();
        }

		@JsonCreator
		public static TransactionStatus fromString(String value) {
			for (TransactionStatus status : TransactionStatus.values()) {
				if (status.name().equalsIgnoreCase(value)) {
					return status;
				}
			}
			throw new IllegalArgumentException("Invalid transaction status: " + value);
		}
    }
}
